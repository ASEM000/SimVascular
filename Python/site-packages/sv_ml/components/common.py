#import joblib
import numpy as np
import os
#import skimage.filters as filters

from sv_ml.modules.vessel_regression import pred_to_contour
import sv_ml.modules.vessel_regression as vessel_regression

from sv_ml.base.preprocessor import AbstractPreProcessor
from sv_ml.base.postprocessor import AbstractPostProcessor
EPS = 1e-5

def gauss_filter(img, sigma=3, trunc=4):
    b = sigma*trunc
    x = np.arange(-b,b+1)

    X,Y = np.meshgrid(x,x)

    d = (X**2+Y**2)/(2*sigma**2)

    f = 1.0/(2*np.pi*sigma**2)*np.exp(-d)

    H,W = img.shape
    im_pad = np.zeros((H+2*b, W+2*b))
    im_pad[b:H+b,b:W+b] = img

    out = np.zeros((H,W))
    print(f.shape)
    for i in range(b,H+b):
        for j in range(b,W+b):
            out[i-b,j-b] = np.sum(im_pad[i-b:i+b+1,j-b:j+b+1]*f)

    return out

class BasePreProcessor(AbstractPreProcessor):
    def __call__(self, x):
        if not 'IMAGE_TYPE' in self.config:
            mu  = 1.0*np.mean(x)
            sig = 1.0*np.std(x)+EPS
            x_   = (x-mu)/sig
        else:
            # if self.config['IMAGE_TYPE'] == 'EDGE':
            #     x_ = filters.sobel(x)
            #     ma = np.amax(x_)
            #     mi = np.amin(x_)
            #     x_ = (x_-mi)/(ma-mi+EPS)
            #
            # if self.config['IMAGE_TYPE'] == 'HESSIAN':
            #     x_ = filters.gaussian(x, sigma=self.config['BLUR_SIGMA'])
            #     x_ = filters.sobel(x_)
            #     x_ = filters.sobel(x_)
            #     mu  = 1.0*np.mean(x_)
            #     sig = 1.0*np.std(x_)+EPS
            #     x_   = (x_-mu)/sig
            #     c = self.config['CLIP_VAL']
            #     x_[x_>c] = c
            #     x_[x_<-c] = -c
            #
            # if self.config['IMAGE_TYPE'] == 'CLIP':
            #     mu  = 1.0*np.mean(x)
            #     sig = 1.0*np.std(x)+EPS
            #     x_   = (x-mu)/sig
            #     c = self.config['CLIP_VAL']
            #     x_[x_>c] = c
            #     x_[x_<-c] = -c

            if self.config['IMAGE_TYPE'] == 'BLUR':
                #x_ = filters.gaussian(x, sigma=self.config['BLUR_SIGMA'])
                x_  = gauss_filter(x, sigma=self.config['BLUR_SIGMA'])
                mu  = 1.0*np.mean(x_)
                sig = 1.0*np.std(x_)+EPS
                x_   = (x_-mu)/sig

        x_ = x_.reshape(self.config['INPUT_DIMS'])

        return x_.copy()

class BasePostProcessor(AbstractPostProcessor):
    def setup(self):
        self.scale = self.config['CROP_DIMS']*self.config['SPACING']/2

    def __call__(self,y):
        c = pred_to_contour(y)
        return c*self.scale

class PointPostProcessor(AbstractPostProcessor):
    def setup(self):
        self.scale = self.config['CROP_DIMS']*self.config['SPACING']/2

    def __call__(self,y):
        c = vessel_regression.point_pred_to_contour(y)
        return c*self.scale
