# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
This module handles file i/o for the SimVascular 1D solver (https://github.com/SimVascular/oneDSolver).
"""
from os import path
import logging
import re
from .manage import get_logger_name
from .parameters import OutflowBoundaryConditionType, MaterialModel
import pdb

import numpy as np


import vtk.util.numpy_support as nps
from vtk import vtkIdList
from vtk import vtkPoints, vtkLine, vtkCellArray, vtkPolyData, vtkXMLPolyDataWriter
from .utils import SurfaceFileFormats, read_polydata, write_polydata
from .io_headers import Headers
from collections import namedtuple

# Define flow data tuple.
FlowData = namedtuple('FlowData', 'time flow')


def read_inflow_file(mesh, params):
    """ Read the inflow file.

    The file can be formatted as space- or comma-separated value pairs.

    Example:   
        <time1>  <flow1>
        <time2>  <flow2>
        ...
        <timeN>  <flowN>
    """
    mesh.logger.info("Read inflow BC ...")
    inflow_data = []
    inflow_file = params.inflow_input_file

    try:
        with open(inflow_file, "r") as ofile:
            for line in ofile:
                if line.strip() == '':
                    continue
                values = re.split("[, ]+", line.strip())
                inflow_data.append(FlowData(time=float(values[0]), flow=float(values[1])))
        # __with open(inflow_file, "r") as ofile

    except Exception as e:
        msg = "The inflow file is in the wrong format, expecting space- or comma-separated value pairs.\n"
        mesh.logger.error(msg)
        raise RuntimeError(str(e))

    mesh.inflow_data = inflow_data


def read_outlet_face_names(mesh, params):
    """ Read in outlet face names file.
    """
    outlet_face_names = []
    mesh.logger.info("Read model outlet face names from: %s" % params.outlet_face_names_file)
    with open(params.outlet_face_names_file) as file:
        for line in file:
            outlet_face_names.extend(line.splitlines())
    mesh.logger.info("Number of model outlet faces names: %d" % len(outlet_face_names))
    return outlet_face_names


def write_mesh(mesh, params):
    """
    Write the 1D mesh to a VTK VTP format file.
    Args:
        params: 1d model parameters
    """
    output_dir = params.output_directory
    file_name = path.join(output_dir, params.mesh_output_file)

    # Add nodes.
    nodes = mesh.nodes
    lcoef = params.lcoef
    points = vtkPoints()
    for i in range(0, len(nodes)):
        points.InsertNextPoint([lcoef * nodes[i][0], lcoef * nodes[i][1], lcoef * nodes[i][2]])

    # Add connectivity.
    seg_head = mesh.seg_head
    seg_rear = mesh.seg_rear
    num_seg = mesh.num_seg
    lines = vtkCellArray()

    for i in range(0, num_seg):
        id1 = seg_head[i]
        id2 = seg_rear[i]
        line = vtkLine()
        line.GetPointIds().SetId(0, id1)
        line.GetPointIds().SetId(1, id2)
        lines.InsertNextCell(line)

    # Create polydata.
    polydata = vtkPolyData()
    polydata.SetPoints(points)
    polydata.SetLines(lines)
    polydata.Modified()

    # add fields to output
    area = [mesh.group_Ain[0]] + np.array(mesh.group_Aout)[mesh.seg_list].tolist()
    length = np.array(mesh.group_length)[mesh.seg_list]
    add_array(polydata, 'point', area, 'area')
    add_array(polydata, 'point', np.arange(len(mesh.nodes)), 'point_id')
    add_array(polydata, 'cell', mesh.seg_list, 'seg_id')
    add_array(polydata, 'cell', length, 'length')

    # Write the VTP file.
    writer = vtkXMLPolyDataWriter()
    writer.SetFileName(file_name)
    writer.SetInputData(polydata)
    writer.Write()


def write_results(mesh, params, centerline_list, group_list):
    ## Write connectivity and other information.
    #
    output_dir = params.output_directory
    file_name = path.join(output_dir, mesh.OutputFileNames.CONNECTIVITY_GROUP_ID)
    with open(file_name, "w") as file:
        for i in range(0, len(mesh.connectivity)):
            for j in range(0, len(mesh.connectivity[i])):
                file.write(str(mesh.connectivity[i][j]) + " ")
            file.write("\n")
    # __with open(file_name, "w") as file

    ## Output outlet face names with the corresponding group id
    #
    # print("#### centerline_list: ", centerline_list)

    if mesh.outlet_face_names:
        outlet_face_names = mesh.outlet_face_names
        file_name = path.join(output_dir, mesh.OutputFileNames.OUTLET_FACE_GROUP_ID)
        with open(file_name, "w") as file:
            for i in range(mesh.num_groups):
                if mesh.group_terminal[i] == 1:
                    temp_elem_id = mesh.group_elems[i][0]
                    temp_path_id = centerline_list[temp_elem_id]
                    file.write(outlet_face_names[temp_path_id] + " " + "GroupId " + str(i) + "\n")
        # __with open(file_name, "w") as file
    # __if len(mesh.outlet_face_names) ! = 0

    file_name = path.join(output_dir, mesh.OutputFileNames.CENTERLINE_GROUP_ID)
    with open(file_name, "w") as file:
        for i in range(mesh.num_paths):
            file.write("Centerline " + str(i) + " " + str(group_list[mesh.path_elems[i][0]]))
            tmpgroupid = group_list[mesh.path_elems[i][0]]
            for j in range(1, len(mesh.path_elems[i])):
                if group_list[mesh.path_elems[i][j]] != tmpgroupid:
                    file.write(" " + str(group_list[mesh.path_elems[i][j]]))
                    tmpgroupid = group_list[mesh.path_elems[i][j]]
            file.write("\n")
        # __for i in range(0,num_paths)
    # __with open(file_name, "w") as file


def write_solver_file(mesh, params, centerline_list):
    """ Write a solver input file.
    """
    # print("Write solver file.")
    mesh.logger.info("Write solver file.")
    output_dir = params.output_directory
    file_name = path.join(output_dir, params.solver_output_file)
    model_name = params.model_name
    sp = mesh.space
    # print("Solver file %s" % file_name)

    # Open file
    ofile = mesh.Open(file_name, "w")

    # Write header
    ofile.writeln("# ================================")
    ofile.writeln("# " + model_name + " MODEL - UNITS IN CGS")
    ofile.writeln("# ================================")
    ofile.writeln("")

    # Write model header.
    ofile.writeln("# ==========")
    ofile.writeln("# MODEL CARD")
    ofile.writeln("# ==========")
    ofile.writeln("# - Name of the model (string)")
    ofile.writeln("")
    ofile.writeln("MODEL " + model_name)
    ofile.writeln("")

    # Write node section.
    write_solver_nodes(mesh, ofile, params)

    # Write joint section.
    write_solver_joints(mesh, ofile, params)

    # Write segment section.
    write_solver_segments(mesh, ofile, params, centerline_list)

    # Write SolverOptions section.
    write_solver_options(mesh, ofile, params)

    # Write material section.
    write_solver_material(mesh, ofile, params)

    # Write output section.
    write_solver_output(mesh, ofile, params)

    ofile.close()


def write_solver_nodes(mesh, ofile, params):
    """ Write a solver input file nodes section.
    """
    header = Headers().node

    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header)

    nodes = mesh.nodes
    lcoef = params.lcoef
    sp = mesh.space

    for i in range(0, len(nodes)):
        ofile.writeln("NODE " + str(i) + sp + sp.join(str(lcoef * nodes[i][j]) for j in range(3)))


def write_solver_joints(mesh, ofile, params):
    """ Write a solver input file joints section.
    """
    header1 = Headers().joint1
    header2 = Headers().joint2

    # Joint header.
    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header1)

    # JointInlet and JointOutlet header.
    ofile.writeln(mesh.solver_file_msg)
    write_solver_section_header(mesh, ofile, header2)

    sp = mesh.space
    seg_connectivity = mesh.seg_connectivity
    seg_rear = mesh.seg_rear

    for i in range(0, len(seg_connectivity)):
        pargroupid = seg_connectivity[i][0]
        joint = "JOINT J" + str(i) + sp + str(seg_rear[pargroupid])
        jin = "IN" + str(i)
        jout = "OUT" + str(i)
        ofile.writeln(joint + sp + jin + sp + jout)
        ofile.writeln("JOINTINLET IN" + str(i) + sp + "1 " + str(seg_connectivity[i][0]))
        ofile.write("JOINTOUTLET OUT" + str(i) + sp + str(len(seg_connectivity[i]) - 1))
        for j in range(1, len(seg_connectivity[i])):
            ofile.write(sp + str(seg_connectivity[i][j]))
        ofile.write("\n\n")


def write_solver_segments(mesh, ofile, params, centerline_list):
    """ Write a solver input file joints section.
    """
    header = Headers().segment
    write_solver_section_header(mesh, ofile, header)
    mesh.logger.info("Write solver segment section ...")

    sp = mesh.space
    num_path = mesh.num_paths
    num_seg = mesh.num_seg
    seg_list = mesh.seg_list
    seg_rear = mesh.seg_rear
    seg_head = mesh.seg_head
    group_elems = mesh.group_elems
    group_length = mesh.group_length
    group_terminal = mesh.group_terminal
    group_Ain = mesh.group_Ain
    group_Aout = mesh.group_Aout
    bc_list = mesh.bc_list
    outlet_face_names = mesh.outlet_face_names
    outlet_face_names_index = mesh.outlet_face_names_index

    uniform_bc = params.uniform_bc
    outflow_bc = params.outflow_bc_type
    outflow_bc_uc = params.outflow_bc_type.upper()  # 1D solve needs upper case.
    uniform_material = params.uniform_material
    dx = params.element_size
    min_num_elems = params.min_num_elems
    inflow_data = mesh.inflow_data

    mesh.logger.info("Uniform BC: %s" % uniform_bc)
    mesh.logger.info("Outflow BC: %s" % outflow_bc)
    mesh.num_elements = 0

    for i in range(0, num_seg):
        if uniform_material:
            matname = "MAT1"
        else:
            matname = "MAT_group" + str(seg_list[i])

        numfe = int(round(group_length[seg_list[i]] / dx))

        if numfe < min_num_elems:
            numfe = min_num_elems

        mesh.num_elements += numfe

        ofile.write("SEGMENT" + sp + "Group" + str(seg_list[i]) + "_Seg" + str(i) + sp + str(i) + sp +
                    str(group_length[seg_list[i]]) + sp + str(numfe) + sp + str(seg_head[i]) + sp +
                    str(seg_rear[i]) + sp + str(group_Ain[seg_list[i]]) + sp + str(group_Aout[seg_list[i]]) + sp +
                    "0.0 " + matname + " NONE 0.0 0 0 ")

        if group_terminal[seg_list[i]] == 1:
            if uniform_bc:
                outflow_bc = OutflowBoundaryConditionType.RCR.upper()
                ofile.writeln(outflow_bc + " " + outflow_bc + "_1")
                msg = "While writing solver segments encountered: group_terminal[seg_list[i]] == 1"
                mesh.logger.error(msg)
                raise RuntimeError(msg)
            else:
                temp_group_id = seg_list[i]
                temp_elem_id = group_elems[temp_group_id][0]
                temp_path_id = centerline_list[temp_elem_id]
                outlet_face = outlet_face_names[temp_path_id]
                map_val = mesh.bc_map[outlet_face]
                ofile.writeln(outflow_bc_uc + " " + outflow_bc_uc + "_" + str(temp_path_id))
        else:
            ofile.writeln("NOBOUND NONE")
            # __for i in range(0,num_seg)

    ofile.writeln("")
    ofile.writeln("")

    if uniform_bc:
        ofile.writeln("DATATABLE " + outflow_bc_uc + "_1 LIST")
        ofile.writeln(sp)
        ofile.writeln("ENDDATATABLE")
        ofile.writeln("")
    else:
        if outflow_bc == OutflowBoundaryConditionType.RCR:
            for i in range(0, num_path):
                ofile.writeln("DATATABLE " + outflow_bc_uc + "_" + str(i) + " LIST")
                outlet_face = outlet_face_names[i]
                map_val = mesh.bc_map[outlet_face]
                bc_data = map_val[1]
                for j in range(0, len(bc_list[i])):
                    ofile.writeln("0.0 " + str(bc_data[j]))
                ofile.writeln("ENDDATATABLE")
                ofile.writeln("")
            # __for i in range(0,num_path)

        elif outflow_bc == OutflowBoundaryConditionType.RESISTANCE:
            for i in range(0, num_path):
                ofile.writeln("DATATABLE " + outflow_bc_uc + "_" + str(i) + " LIST")
                ofile.writeln("0.0 " + str(bc_list[i]))
                ofile.writeln("ENDDATATABLE")
                ofile.writeln("")
            # __for i in range(0,num_path)
        # __elif outflow_bc == OutflowBoundaryConditionType.RESISTANCE
    # __if uniform_bc

    ofile.writeln("")
    ofile.writeln("")
    ofile.writeln("DATATABLE INFLOW LIST")

    if not inflow_data:
        ofile.writeln("Copy and paste inflow data here.")
    else:
        for value in inflow_data:
            ofile.writeln(" %f %f" % (value.time, value.flow))
    # _if not inflow_file

    ofile.writeln("ENDDATATABLE")
    ofile.writeln("")
    ofile.writeln("")


def write_solver_options(mesh, ofile, params):
    """ Write a solver input file options section.
    """
    header = Headers().solveroptions
    write_solver_section_header(mesh, ofile, header)

    sp = mesh.space
    time_step = params.time_step
    num_time_steps = params.num_time_steps
    save_data_freq = params.save_data_freq

    ofile.writeln("SOLVEROPTIONS " + str(time_step) + " " + str(save_data_freq) + " " + str(
        num_time_steps) + " 2 INFLOW FLOW 1.0e-5 1 1")
    ofile.writeln("")


def write_solver_material(mesh, ofile, params):
    """ Write a solver input file material section.
    """
    header = Headers().material
    write_solver_section_header(mesh, ofile, header)

    sp = mesh.space
    mattype = params.material_model
    density = params.density
    viscosity = params.viscosity

    if mattype == MaterialModel.OLUFSEN:
        k1 = params.olufsen_material_k1
        k2 = params.olufsen_material_k2
        k3 = params.olufsen_material_k3
        pressure = params.olufsen_material_pressure
        exponent = params.olufsen_material_exponent
    elif mattype == MaterialModel.LINEAR:
        k1 = params.linear_material_ehr
        k2 = 0.0
        k3 = 0.0
        pressure = params.linear_material_pressure
        exponent = 1.0

    uniform_material = params.uniform_material

    if uniform_material:
        ofile.writeln("MATERIAL MAT1 " + mattype + sp + str(density) + sp + str(viscosity) + sp +
                      str(pressure) + sp + str(exponent) + sp + str(k1) + sp + str(k2) + sp + str(k3))

    if not uniform_material:
        for i in range(0, num_seg):
            tmp = 4.0 / 3.0 * matlist[seg_list[i]][0] * matlist[seg_list[i]][1] / math.sqrt(
                (group_Ain[seg_list[i]] + group_Aout[seg_list[i]]) / 2 / 3.14)
            ofile.writeln("MATERIAL MAT_group" + str(seg_list[i]) + sp + mattype + sp + str(density) + sp + str(
                viscosity) + sp +
                          str(pressure) + sp + str(exponent) + sp + str(k1) + sp + str(k2) + sp + str(tmp))


def write_solver_output(mesh, ofile, params):
    """ Write a solver input file output section.
    """
    header = Headers().output
    ofile.writeln("")
    write_solver_section_header(mesh, ofile, header)

    outputformat = params.outputformat
    ofile.writeln("OUTPUT " + outputformat)


def write_solver_section_header(mesh, ofile, header):
    """ Write a solver input file section header.
    """
    endl = mesh.endl
    hdr = endl.join(line for line in header)
    ofile.writeln(hdr)


def add_array(data, identifier, array, name):
    """
    Add array to vtkPolyData
    Args:
        data: vtkPolyData object
        identifier: array association (point or cell)
        array: scalar list or numpy array
        name: display name of array
    """
    out_array = nps.numpy_to_vtk(np.array(array))
    out_array.SetName(name)
    if identifier == 'point':
        data.GetPointData().AddArray(out_array)
    elif identifier == 'cell':
        data.GetCellData().AddArray(out_array)
    else:
        raise ValueError('Unknown identifier ' + identifier + '. Choose point or cell.')
