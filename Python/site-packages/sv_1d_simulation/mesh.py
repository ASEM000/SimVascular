# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
This module is used to create an input file for the SimVascular 1D solver (https://github.com/SimVascular/oneDSolver).

A 1D mesh is generated from the centerline geometry caculated from a closed polygonal surface.

A centerline consists of m cells, m=number of tract ids, the length of a cell/line is an approximation of a group. 
In Cell Data, lines are listed from 0 to m. For each line, the first number is the number of points for this line 
followed by 1st point to the last point.

"""
from os import path
import logging
import re
from .manage import get_logger_name
from .parameters import OutflowBoundaryConditionType, MaterialModel
from collections import OrderedDict
from scipy.interpolate import interp1d
import pdb

import numpy as np

try:
    from vmtk import vmtkscripts
except ImportError:
    print("vmtk not found.")

import vtk.util.numpy_support as nps
from vtk import vtkIdList
from vtk import vtkPoints, vtkLine, vtkCellArray, vtkPolyData, vtkXMLPolyDataWriter
from .utils import SurfaceFileFormats, read_polydata, write_polydata
from .io import read_inflow_file, read_outlet_face_names, write_mesh, write_results, write_solver_file, \
    write_solver_nodes, write_solver_joints, write_solver_segments, write_solver_options, \
    write_solver_material, write_solver_output, write_solver_section_header
from collections import namedtuple

# Define flow data tuple.
FlowData = namedtuple('FlowData', 'time flow')


class Mesh(object):
    """ The Mesh class is used to encapsulate 1D mesh calculations.

    Attributes:
        path_elems (list[int]): Records the element indices for centerline ids.
    """

    class OutputFileNames(object):
        """ This class defines the output file names for writing connectivity information.
        """
        CONNECTIVITY_GROUP_ID = "connectivity_groupid.dat"
        OUTLET_FACE_GROUP_ID = "outletface_groupid.dat"
        CENTERLINE_GROUP_ID = "centerline_groupid.dat"

    class CellDataFields(object):
        """ This class defines the required field cell data field names.
        """
        CENTERLINE_IDS = "CenterlineIds"
        BLANKING = "Blanking"
        GROUP_IDS = "GroupIds"
        TRACT_IDS = "TractIds"

    class PointDataFields(object):
        """ This class defines the required field point data field names.
        """
        MAX_INSCRIBED_RADIUS = "MaximumInscribedSphereRadius"

    class Open(object):
        """ This class wraps the 'open' class and adds a method to automatically 
            write newlines. 
        """

        def __init__(self, *args, **kwds):
            self.args = args
            self.kwds = kwds
            self.file_obj = open(*self.args, **self.kwds)

        def __enter__(self):
            self.file_obj = open(*self.args, **self.kwds)
            return self

        def __exit__(self, *args):
            self.file_obj.close()

        def close(self):
            self.file_obj.close()

        def writeln(self, string):
            self.file_obj.write(string + '\n')

        def write(self, string):
            self.file_obj.write(string)

    def __init__(self):
        self.centerlines = None
        self.logger = logging.getLogger(get_logger_name())
        self.num_cells = None
        self.num_paths = None
        self.path_elems = None
        self.group_elems = None
        self.materials = None
        self.num_seg = None
        self.seg_list = None
        self.group_seg = None
        self.group_terminal = None
        self.group_length = None
        self.group_Ain = None
        self.group_Aout = None
        self.num_groups = None
        self.connectivity = None
        self.seg_connectivity = None
        self.seg_head = None
        self.seg_rear = None
        self.nodes = None
        self.num_elements = None
        self.user_outlet_paths = None
        self.bc_list = None
        self.bc_map = None
        self.inflow_data = None

        self.outlet_face_names = None
        self.outlet_face_names_index = None

        self.centerlines = None
        self.centerlines_geometry = None

        # Some constansts for writing the solver file.
        self.solver_file_msg = "\n\n### DO NOT CHANGE THIS SECTION - generated automatically"
        self.space = " "
        self.endl = "\n"

    def generate(self, params, centerlines):
        """ Generate a mesh.
        """
        self.centerlines = centerlines
        self.logger.info("Generate the 1D mesh ...")
        self.centerlines_geometry = centerlines.branch_geometry

        # Set outlet face names.
        self.set_outlet_face_names(params)
        self.logger.info("Outlet face names: %s" % str(self.outlet_face_names))

        # Check that centerline geometry has the required data fields.
        if not self.check_centerlines_data():
            return False

        # Get centerline data.
        fields = self.CellDataFields
        centerline_list = self.get_cell_data(fields.CENTERLINE_IDS)
        blank_list = self.get_cell_data(fields.BLANKING)
        group_list = self.get_cell_data(fields.GROUP_IDS)
        tract_list = self.get_cell_data(fields.TRACT_IDS)
        self.num_cells = self.centerlines_geometry.GetNumberOfCells()
        self.num_paths = centerline_list[-1] + 1
        self.num_groups = max(group_list) + 1
        self.logger.info("Number of cells: %d" % self.num_cells)
        self.logger.info("Number of paths: %d" % self.num_paths)
        self.logger.info("Number of groups: %d" % self.num_groups)

        self.set_path_elements(centerline_list)
        self.set_group_elements(group_list)

        if not params.uniform_bc:
            self.set_variable_outflow_bcs(params)

        if params.inflow_input_file:
            read_inflow_file(self, params)

        if not params.uniform_material:
            materials = self.generate_grouped_wall_properties(params)

        self.calculate_connectivity(params, blank_list, centerline_list, group_list, tract_list)

        self.calculate_seg_lengths(params, centerline_list, group_list, tract_list)

        self.calculate_node_coordinates(centerline_list, group_list, tract_list)

        self.calculate_refinement(params)

        if params.reorganize_seqments:
            self.reorganize_child_segments(centerline_list, group_list, tract_list)

        if params.write_mesh_file:
            write_mesh(self, params)

        if params.write_solver_file:
            write_solver_file(self, params, centerline_list)
            write_results(self, params, centerline_list, group_list)

    def calculate_refinement(self, params):
        # divide each master-segment in num_div sub-segments
        num_div = params.refinement

        # nothing to do
        if num_div == 1:
            return

        # catch functionality that is currently not supported by refinement
        if not params.uniform_material:
            msg = 'Not implemented.\n'
            self.logger.error(msg)
            raise RuntimeError(msg)

        # step 1: create refined connectivity
        # end node of segment
        seg_rear = np.arange(0, self.num_seg * num_div) + 1

        # start node of segment
        seg_head = seg_rear - 1
        seg_head[::num_div] = np.array(self.seg_head) * num_div

        # add existing joints (bifurcations)
        seg_connectivity = []
        for c in self.seg_connectivity:
            # inlet segment: last sub-segment of master-segment
            joint = [(c[0] + 1) * num_div - 1]

            # outlet segments: first sub-segments of master-segments
            joint += (np.array(c[1:]) * num_div).tolist()

            seg_connectivity.append(joint)

        # add new joints for connected sub-segments of a master-segment
        for i in range(self.num_seg):
            for j in range(num_div - 1):
                seg_connectivity.append([i * num_div + j, i * num_div + j + 1])

        # step 2: create refined nodes / areas / segment lengths
        # get area on each point on centerline
        area = np.pi * self.get_point_data(self.PointDataFields.MAX_INSCRIBED_RADIUS) ** 2

        # list of node coordinates. start with inlet node
        nodes = [self.centerlines_geometry.GetPoints().GetPoint(0)]

        # initialize properties of sub-segments (to replace master-segments later)
        areas_in = []
        areas_out = []
        group_elems = []
        group_length = []
        group_terminal = []

        # loop all master-segments
        for i in self.seg_list:
            # initialize sub-segment areas that are averaged over all (mostly overlapping) elements
            areas_g = np.zeros(num_div + 1)

            # loop all centerline elements of master-segment group
            for j in reversed(range(len(self.group_elems[i]))):
                # get element
                c = self.centerlines_geometry.GetCell(self.group_elems[i][j])

                # get point coordinates and global ids
                points = nps.vtk_to_numpy(c.GetPoints().GetData())
                point_ids = np.array([c.GetPointIds().GetId(i) for i in range(c.GetPointIds().GetNumberOfIds())])

                # map 1d centerline path to interval [0,1]
                path_1d = np.cumsum(np.insert(np.linalg.norm(np.diff(points, axis=0), axis=1), 0, 0))
                path_1d /= path_1d[-1]

                # create sub-nodes uniformly along centerline element
                # todo: adaptive mesh refinement based on gradient of centerline area
                sample_1d = np.linspace(0, 1, num_div + 1)

                # interpolate along 1d centerline and add to cumulative sum
                areas_g += interp1d(path_1d, area[point_ids])(sample_1d)

            # get average over all group elements
            areas_g *= params.Acoef / len(self.group_elems[i])

            # get first group element for nodes, not average (consistency with with case num_div = 1)
            nodes_g = interp1d(path_1d, points.T)(sample_1d[1:]).T

            # loop all sub-segments to collect information for output
            for j in range(num_div):
                # append sub-nodes
                nodes.append(tuple(params.lcoef * nodes_g[j]))

                # split in segment in/out
                areas_in.append(areas_g[j])
                areas_out.append(areas_g[j + 1])

                # every sub-segment in master-segment belongs to the same element
                group_elems.append(self.group_elems[i])

                # divide master-segment length uniformly among sub-segments
                group_length.append(self.group_length[i] / num_div)

                # only last sub-segment of master-segment is outlet
                if self.group_terminal[i] == 1 and j == num_div - 1:
                    group_terminal.append(1)
                else:
                    group_terminal.append(0)

        # step 3: update mesh
        self.nodes = nodes
        self.num_seg *= num_div
        self.num_groups = self.num_seg

        self.seg_list = np.arange(self.num_seg).tolist()
        self.seg_rear = seg_rear
        self.seg_head = seg_head

        self.group_Ain = areas_in
        self.group_Aout = areas_out

        self.group_elems = group_elems
        self.group_length = group_length
        self.group_terminal = group_terminal

        self.seg_connectivity = seg_connectivity

    def calculate_connectivity(self, params, blank_list, centerline_list, group_list, tract_list):
        """ calculate connectivity.
        """

        # Calculate segments lists and group segments.
        seg_list, group_seg, group_terminal = self.calculate_seg_lists(blank_list)
        num_seg = len(seg_list)

        # Create connectivity for segments.
        connectivity = []

        for i in range(num_seg):
            # If  groupid is not a terminal seg, then it is a parent seg.
            if group_terminal[seg_list[i]] != 0:
                continue
            pargroupid = seg_list[i]
            temp_conn = [pargroupid]

            # For each non-terminal group, at least there are 2 paths going through 
            # the child segments and sharing this group.
            pathid1 = centerline_list[self.group_elems[pargroupid][0]]
            tractid1 = tract_list[self.group_elems[pargroupid][0]]

            # Find the corresponding element id in path_elems list and index+1 is 
            # the bifurcation index+2 is the child elem
            childelemid1 = self.path_elems[pathid1][tractid1 + 2]
            childgroupid1 = group_list[childelemid1]
            temp_conn.append(childgroupid1)

            # Find second child or third/fourth child.
            for j in range(len(self.group_elems[pargroupid]) - 1, 0, -1):
                temppathid = centerline_list[self.group_elems[pargroupid][j]]
                temptractid = tract_list[self.group_elems[pargroupid][j]]
                tempelemid = self.path_elems[temppathid][temptractid + 2]
                tempgroupid = group_list[tempelemid]
                repeat = 0
                for k in range(1, len(temp_conn)):
                    if tempgroupid == temp_conn[k]:
                        repeat = 1
                        break

                if repeat == 0:
                    temp_conn.append(tempgroupid)

            if len(temp_conn) > 3:
                msg = "There are more than 2 child segments for groupid %s" % str(pargroupid)
                self.logger.warning(msg)

            connectivity.append(temp_conn)

        seg_connectivity = []

        for i in range(len(connectivity)):
            temp_conn = []
            for j in range(len(connectivity[i])):
                temp_conn.append(group_seg[connectivity[i][j]])
            seg_connectivity.append(temp_conn)

        self.num_seg = num_seg
        self.seg_list = seg_list
        self.group_seg = group_seg
        self.group_terminal = group_terminal
        self.connectivity = connectivity
        self.seg_connectivity = seg_connectivity

    def calculate_seg_lists(self, blank_list):
        """ Calculate segment list and group segments.
        """
        group_terminal = self.num_groups * [0]
        num_outlet = 0
        num_bif = 0
        tmp = len(self.group_elems[0])

        for i in range(self.num_groups):
            if blank_list[self.group_elems[i][0]] == 1:
                group_terminal[i] = 2
                num_bif += 1
            if (len(self.group_elems[i]) == 1) and (blank_list[self.group_elems[i][0]] != 1):
                group_terminal[i] = 1
                num_outlet += 1

            if (len(self.group_elems[i]) > tmp) and (blank_list[self.group_elems[i][0]] != 1):
                tmp = len(self.group_elems[i])
                self.logger.warning("A group with id>0 contains more centerlines than group 0")

        if (tmp != len(self.group_elems[0])) or (tmp != num_outlet) or (self.num_paths != num_outlet):
            msg = "Inlet group id is not 0 or number of centerlines is not equal to the number of outlets"
            self.logger.error(msg)
            self.logger.error("num_paths=%d num_outlet=%d  len(self.group_elems[0])=%d  tmp=%s" % \
                              (self.num_paths, num_outlet, len(self.group_elems[0]), tmp))
            raise RuntimeError(msg)

        num_seg = self.num_groups - num_bif

        seg_list = []
        group_seg = []

        for i in range(self.num_groups):
            if group_terminal[i] != 2:
                seg_list.append(i)
                group_seg.append(len(seg_list) - 1)
            else:
                group_seg.append(-1)

        if len(seg_list) != num_seg:
            msg = "Length of seg_list %d is not equal to num_seg %d" % (len(seg_list), num_seg)
            self.logger.error(msg)
            raise RuntimeError(msg)

        return seg_list, group_seg, group_terminal

    def calculate_seg_lengths(self, params, centerline_list, group_list, tract_list):
        """ calculate seg length, Ain and Aout
        """
        group_length = []
        group_Ain = []
        group_Aout = []

        # Get max inscribed sphere radius data.
        points_maxR = self.get_point_data(self.PointDataFields.MAX_INSCRIBED_RADIUS)

        for i in range(self.num_groups):
            tmpl = 0.0
            tmpAin = 0.0
            tmpAout = 0.0

            for j in range(0, len(self.group_elems[i])):
                # get cell
                cell = self.centerlines_geometry.GetCell(self.group_elems[i][j])

                ids = vtkIdList()
                self.centerlines_geometry.GetCellPoints(self.group_elems[i][j], ids)
                num_ids = ids.GetNumberOfIds()
                tmpAin += np.pi * points_maxR[ids.GetId(0)] ** 2
                tmpAout += np.pi * points_maxR[ids.GetId(num_ids - 1)] ** 2

                # point distances (exclude last point for legacy behavior)
                diff = np.diff(nps.vtk_to_numpy(cell.GetPoints().GetData())[:-1], axis=0)

                # segment length
                tmpl += np.sum(np.linalg.norm(diff, axis=1))

            tmpl *= params.lcoef / len(self.group_elems[i])
            tmpAin *= params.Acoef / len(self.group_elems[i])
            tmpAout *= params.Acoef / len(self.group_elems[i])

            if (tmpAin < tmpAout) and (self.group_terminal[i] != 2):
                temp_elem_id = self.group_elems[i][0]
                temp_path_id = centerline_list[temp_elem_id]
                face_name = self.outlet_face_names[temp_path_id]
                self.logger.warning("Ain < Aout for group id %d, face name '%s'" % (i, face_name))
                self.logger.warning("This will cause problems for the 1D solver so setting Ain = Aout")
                tmpAin = tmpAout

            # For bifurcation group, approximate as a straight uniform cylinder.
            if self.group_terminal[i] == 2:
                tmpAin = (tmpAin + tmpAout) / 2.0
                tmpAout = tmpAin

            group_length.append(tmpl)
            group_Ain.append(tmpAin)
            group_Aout.append(tmpAout)

        # Modify seg length, add bifurcation group length to the parent group.
        for i in range(self.num_seg):
            if self.group_terminal[self.seg_list[i]] != 1:
                pargroupid = self.seg_list[i]
                pathid1 = centerline_list[self.group_elems[pargroupid][0]]
                tractid1 = tract_list[self.group_elems[pargroupid][0]]
                # Find the bifurcation group.
                bifelem = self.path_elems[pathid1][tractid1 + 1]
                bifgroupid = group_list[bifelem]
                # Add the bifurcation group length to the parent group.
                group_length[pargroupid] = group_length[pargroupid] + group_length[bifgroupid]

        self.group_length = group_length
        self.group_Ain = group_Ain
        self.group_Aout = group_Aout

    def calculate_node_coordinates(self, centerline_list, group_list, tract_list):
        """ get node coordinates 
        """
        nodes = []
        # Parent group id for node(i).
        grouprearnodeid = []
        ids = vtkIdList()
        self.centerlines_geometry.GetCellPoints(0, ids)
        id1 = ids.GetId(0)
        nodes.append(self.centerlines_geometry.GetPoints().GetPoint(id1))

        for i in range(self.num_groups):
            if self.group_terminal[i] == 0 or self.group_terminal[i] == 1:
                tempelemid = self.group_elems[i][0]
                self.centerlines_geometry.GetCellPoints(tempelemid, ids)
                num_ids = ids.GetNumberOfIds()
                id1 = ids.GetId(num_ids - 1)
                nodes.append(self.centerlines_geometry.GetPoints().GetPoint(id1))
                grouprearnodeid.append(len(nodes) - 1)
            else:
                # bifurcation group doesn't get a node id, use nodeid = -1
                grouprearnodeid.append(-1)

        seg_head = []
        seg_rear = []

        for i in range(self.num_seg):
            tempgroupid = self.seg_list[i]
            if tempgroupid == 0:
                seg_head.append(0)
            else:
                tempelemid = self.group_elems[tempgroupid][0]
                temptractid = tract_list[tempelemid]
                temppathid = centerline_list[tempelemid]
                tempelemid = self.path_elems[temppathid][temptractid - 2]
                seg_head.append(grouprearnodeid[group_list[tempelemid]])
            seg_rear.append(grouprearnodeid[tempgroupid])

        self.seg_head = seg_head
        self.seg_rear = seg_rear
        self.nodes = nodes

    def set_group_elements(self, group_list):
        """
        group_elems[i] records the element(line) indices for group id=i
        """
        group_elems = []
        for i in range(self.num_groups):
            group_elems.append([])

        for i in range(self.num_cells):
            group_elems[group_list[i]].append(i)

        self.group_elems = group_elems

    def set_path_elements(self, centerline_list):
        """
        path_elems[i] records the element(line) indices for centerline id=i.
        """
        path_elems = []

        for i in range(self.num_paths):
            path_elems.append([])

        for i in range(self.num_paths):
            for j in range(self.num_cells):
                if i == centerline_list[j]:
                    path_elems[i].append(j)

        self.path_elems = path_elems

    def set_outlet_face_names(self, params):
        """ Set outlet face names.
        """
        if self.centerlines.outlet_face_names is not None:
            outlet_face_names = self.centerlines.outlet_face_names
        else:
            outlet_face_names = read_outlet_face_names(self, params)

        # Create a map between outlet face name and path ID.
        self.outlet_face_names_index = OrderedDict()
        self.outlet_face_names = []
        for i, face_name in enumerate(outlet_face_names):
            self.outlet_face_names.append(face_name)
            self.outlet_face_names_index[face_name] = i

    def generate_grouped_wall_properties(self, params):
        """ Generate grouped wall properties and write them to a file.
        """
        self.logger.info("Generate grouped wall properties ...")
        self.logger.info("Read wall properties file: %s" % params.wall_properties_input_file)
        poly_data = read_polydata(params.wall_properties_input_file)

        branch_clip = vmtkscripts.vmtkBranchClipper()
        branch_clip.Surface = poly_data
        branch_clip.Centerlines = centerlines
        branch_clip.Execute()
        surface = branch_clip.Surface

        self.logger.info("Write wall properties file: %s" % params.wall_properties_output_file)
        write_polydata(params.wall_properties_output_file, surface)

        point_data = surface.GetPointData()
        thickness = nps.vtk_to_numpy(point_data.GetArray('thickness'))
        E = nps.vtk_to_numpy(point_data.GetArray('Young_Mod'))
        group_ids = nps.vtk_to_numpy(point_data.GetArray('GroupIds'))

        group_thickness = []
        group_E = []

        for i in range(self.num_groups):
            group_thickness.append([])
            group_E.append([])

        for i in range(poly_data.GetNumberOfPoints()):
            group_thickness[group_ids[i]].append(float(thickness[i]))
            group_E[group_ids[i]].append(float(E[i]))

        materials = []
        for i in range(self.num_groups):
            thickness_mean = 0.0
            E_mean = 0.0
            if len(group_thickness[i]) != 0:
                thickness_mean = np.mean(group_thickness[i])
                E_mean = np.mean(group_E[i])
            else:
                self.logger.info("Group %d is empty." % i)
            materials.append([thickness_mean, E_mean])
        self.logger.info("Created %d materials." % len(materials))

        return materials

    def set_variable_outflow_bcs(self, params):
        """ Read in data for variable flow boundary conditions.

        Parameters for outflow BCs (resistance or RCR) are read from a file.
        """
        self.logger.info("Set variable outflow boundary conditions ...")
        outlet_face_names = self.outlet_face_names

        # Read outflow BCs parameters from a file.
        bc_file = params.outflow_bc_file
        outflow_bc = params.outflow_bc_type
        bc_list = []
        bc_map = dict()

        if outflow_bc == OutflowBoundaryConditionType.RESISTANCE:
            self.logger.info("Read resistance BCs ...")
            try:
                with open(bc_file) as rfile:
                    for line in rfile:
                        face_name, value = line.strip().split(' ')
                        self.logger.info("Face %s  value %s" % (face_name, value))
                        if not face_name[0].isalpha():
                            msg = "The resistance file is in the wrong format, expecting face name / value pairs."
                            raise RuntimeError(msg)
                        # value = float(rfile.readline())
                        bc_list.append(value)
                        pathID = self.outlet_face_names_index[face_name]
                        bc_map[face_name] = (pathID, value)

            except Exception as e:
                msg = "The resistance file is in the wrong format, expecting face name / value pairs.\n"
                self.logger.error(msg)
                raise RuntimeError(str(e))

            if len(bc_list) != len(outlet_face_names):
                msg = "The number of BC values %d do not match the number of outlets %d." % (
                    len(bc_list), len(outlet_face_names))
                raise RuntimeError(msg)

        elif outflow_bc == OutflowBoundaryConditionType.RCR:
            with open(bc_file, "r") as rfile:
                keyword = rfile.readline()
                while True:
                    tmp = rfile.readline()
                    if tmp == keyword:
                        RCRval = []
                        face_name = rfile.readline().strip()
                        RCRval.append(float(rfile.readline()))
                        RCRval.append(float(rfile.readline()))
                        RCRval.append(float(rfile.readline()))
                        bc_list.append(RCRval)
                        pathID = self.outlet_face_names_index[face_name]
                        bc_map[face_name] = (pathID, RCRval)
                    if len(tmp) == 0:
                        break

        self.bc_list = bc_list
        self.bc_map = bc_map

    def check_centerlines_data(self):
        """ Check that the centerline data contains all of the required fields.
        """
        field_names = [v for k, v in self.CellDataFields.__dict__.items() if not k.startswith('__')]
        for field in field_names:
            if not self.centerlines_geometry.GetCellData().GetArray(field):
                self.logger.error("Centerlines do not contain the '%s' data field." % field)
                return False

        field_names = [v for k, v in self.PointDataFields.__dict__.items() if not k.startswith('__')]
        for field in field_names:
            if not self.centerlines_geometry.GetPointData().GetArray(field):
                self.logger.error("Centerlines do not contain the '%s' data field." % field)
                return False

        return True

    def get_cell_data(self, field):
        """ Get the data for the given cell field names.
        """
        cell_data = self.centerlines_geometry.GetCellData().GetArray(field)
        return nps.vtk_to_numpy(cell_data)

    def get_point_data(self, field):
        """ Get the data for the given cell field names.
        """
        point_data = self.centerlines_geometry.GetPointData().GetArray(field)
        return nps.vtk_to_numpy(point_data)

    # untested functionality
    def reorganize_child_segments(self, centerline_list, group_list, tract_list):
        """ Reorgazie child segments when ireorgseg==1 and the number of child segments>3.
        """
        group_elems = self.group_elems
        path_elems = self.path_elems
        seg_list = self.seg_list
        seg_connectivity = self.seg_connectivity
        cl_geom = self.centerlines_geometry
        points = cl_geom.GetPoints()

        i = 0

        while i < len(seg_connectivity):
            if len(seg_connectivity[i]) > 4:
                # print ("reorganize seg connectivity = ",seg_connectivity[i])
                parsegid = seg_connectivity[i][0]
                pargroupid = seg_list[parsegid]
                num_child = len(seg_connectivity[i]) - 1
                pathid1 = centerline_list[group_elems[pargroupid][0]]
                tractid1 = tract_list[group_elems[pargroupid][0]]
                # Find the bifurcation group
                bifelem = path_elems[pathid1][tractid1 + 1]
                bifgroupid = group_list[bifelem]
                bifl = group_length[bifgroupid]
                dl = bifl / (num_child - 2)
                childsegs = []
                childsegs.extend(seg_connectivity[i][1:])
                # prevously add bif group length to the par group length
                group_length[pargroupid] = group_length[pargroupid] - bifl

                ids = vtkIdList()
                cl_geom.GetCellPoints(group_elems[pargroupid][0], ids)
                num_ids = ids.GetNumberOfIds()
                id1 = ids.GetId(num_ids - 1)  # last node for par seg
                pt1 = np.array([cl_geom.GetPoints().GetPoint(id1)[0], cl_geom.GetPoints().GetPoint(id1)[1],
                                cl_geom.GetPoints().GetPoint(id1)[2]])
                childseg_dist = []

                # Sort child segments based on the distance to the parent segment, and add extra
                # segments along the bifurcation segments instead of connecting all n child segments to 1 outlet
                for j in range(0, len(childsegs)):
                    childgroupid1 = seg_list[childsegs[j]]
                    ids = vtkIdList()
                    cl_geom.GetCellPoints(group_elems[childgroupid1][0], ids)
                    id2 = ids.GetId(0)  # first node in each child seg
                    pt2 = np.array([points.GetPoint(id2)[0], points.GetPoint(id2)[1], points.GetPoint(id2)[2]])
                    childseg_dist.append(np.linalg.norm(pt2 - pt1))
                # __for j in range(0, len(childsegs))

                # print ("childsegs = ",childsegs)
                # print ("dist = ",childseg_dist)
                dist_order = np.argsort(childseg_dist)
                # print ("order = ",dist_order)

                # define bif group starting point and tangential vector
                ids = vtkIdList()
                cl_geom.GetCellPoints(group_elems[bifgroupid][0], ids)
                num_ids = ids.GetNumberOfIds()
                id1 = ids.GetId(0)
                pt1 = np.array([points.GetPoint(id1)[0], points.GetPoint(id1)[1], points.GetPoint(id1)[2]])
                id2 = ids.GetId(int(num_ids / 2))
                pt2 = np.array([points.GetPoint(id2)[0], points.GetPoint(id2)[1], points().GetPoint(id2)[2]])
                v = pt2 - pt1
                v = v / np.linalg.norm(v)

                first_new_seg = len(seg_list)
                parrearnodeid = seg_rear[parsegid]
                if len(seg_list) != len(seg_head) or len(seg_list) != len(seg_rear):
                    print("Something wrong! length of seg_list ! =  length seg_head/seg_rear")

                # Split the bif group into n-2 pieces and change the corresponding group length.
                for j in range(0, num_child - 2):
                    seg_list.append(bifgroupid)
                    # Add rear node for each new seg.
                    pt2 = pt1 + v * dl
                    nodes.append([pt2[0], pt2[1], pt2[2]])
                    seg_rear.append(len(nodes) - 1)
                    seg_head.append(parrearnodeid)
                    pt1 = pt2
                    parrearnodeid = len(nodes) - 1
                # __for j in range(0,num_child-2)

                # modify the group length. the group is splitted into n-2 segments, the length represents the segment length now.
                group_length[bifgroupid] = group_length[bifgroupid] / (num_child - 2)

                # delete original connectivity with >3 child segments, add new segments splitted from the bif group to the connectivity and connect to child segments
                del seg_connectivity[i]
                i = i - 1
                temp_conn = np.zeros((1 + num_child - 2, 3)).astype(int)
                temp_conn[0][0] = parsegid
                # add splitted segments to the parement seg position
                for j in range(0, num_child - 2):
                    temp_conn[j + 1][0] = first_new_seg + j
                # add child segment ids to the temp_conn
                for j in range(0, num_child - 2):
                    temp_conn[j][1] = first_new_seg + j
                    temp_conn[j][2] = childsegs[dist_order[j]]
                # add last two child segments to temp_conn
                temp_conn[num_child - 2][1] = childsegs[dist_order[num_child - 2]]
                temp_conn[num_child - 2][2] = childsegs[dist_order[num_child - 1]]
                for j in range(0, num_child - 1):
                    seg_connectivity.append(temp_conn[j])

                # modify head nodes for child segments
                for j in range(0, num_child - 2):
                    sorted_child_index = dist_order[j]
                    seg_head[childsegs[sorted_child_index]] = seg_head[first_new_seg + j]

                seg_head[childsegs[dist_order[num_child - 2]]] = seg_rear[-1]
                seg_head[childsegs[dist_order[num_child - 1]]] = seg_rear[-1]
            # __if len(seg_connectivity[i])>4

            i = i + 1
        # __while i < len(seg_connectivity)

        # print ("num_seg = ",num_seg)
        num_seg = len(seg_list)
        # print ("redefine num_seg = ",num_seg)
