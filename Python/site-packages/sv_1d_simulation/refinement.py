# Copyright (c) Stanford University, The Regents of the University of
#               California, and others.
#
# All Rights Reserved.
#
# See Copyright-SimVascular.txt for additional details.
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject
# to the following conditions:
#
# The above copyright notice and this permission notice shall be included
# in all copies or substantial portions of the Software.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
# IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
# TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
# PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER
# OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
# LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
# NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
# SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

"""
This module handles mesh refinement for the SimVascular 1D solver (https://github.com/SimVascular/oneDSolver).
"""
from copy import deepcopy, copy
import vtk.util.numpy_support as nps
import numpy as np

from .mesh import *

import pdb


class Refinement(object):
    """
    Take 1D-model created based on vmtk centerlines and refine segments:

    master-segment (= vessel branch from vmtk centerline extraction)

      O===========O
      0           1
       master-node

    sub-segments (newly created in this class, with individual nodes / areas / segment lengths)

      O--|--|--|--O
      0  1  2  3  4
        sub-nodes
    """

    def __init__(self, mesh, params):
        # catch functionality that is currently not supported by refinement
        if not params.uniform_material or params.reorganize_seqments:
            msg = 'Not implemented by refinement.\n'
            mesh.logger.error(msg)
            raise RuntimeError(msg)

        # store original and refined mesh
        self.original = None
        self.fine = None
        self.copy_mesh(mesh)

        # store oneD parameters
        self.params = params

        # number of sub-segments in each master-segment
        self.master_num_seg = None

    def copy_mesh(self, mesh):
        """
        # make deep copy (no reference) of original mesh object to prevent inconsistent Mesh objects during refinement
        # Note: Can't use deepcopy(mesh) from copy module on Mesh because vtkPolyData can't be pickled
        """
        # store and delete objects from mesh that can't be deepcopied (vtk stuff)
        centerlines = mesh.centerlines
        centerlines_geometry = mesh.centerlines_geometry
        del mesh.centerlines
        del mesh.centerlines_geometry

        # deepcopy original mesh
        self.original = deepcopy(mesh)

        # make shallow copy of vtk objects (can be references as these are not modified here)
        self.original.centerlines = centerlines
        self.original.centerlines_geometry = centerlines_geometry

        # store reference to original mesh for output
        self.fine = mesh
        self.fine.centerlines = centerlines
        self.fine.centerlines_geometry = centerlines_geometry

    def calculate(self):
        """
        Do the actual refinement
        """
        # step 1: create refined nodes / areas / segment lengths
        self.refine_physical()

        # step 2: create refined connectivity
        self.refine_connectivity()

    def refine_physical(self):
        """
        Create refined physical quantities: nodes / areas / segment lengths
        """
        # initialize properties of sub-segments in fine mesh to replace those of original mesh
        self.fine.group_Ain = []
        self.fine.group_Aout = []
        self.fine.group_elems = []
        self.fine.group_length = []
        self.fine.group_terminal = []

        # list of node coordinates. start with inlet node
        self.fine.nodes = [self.original.centerlines_geometry.GetPoints().GetPoint(0)]

        # loop all master-segments
        self.master_num_seg = []
        for i in self.original.seg_list:
            # determine number of sub-segments in this master-segment
            num_seg = int(round(self.original.group_length[i] / self.params.seg_size))
            if num_seg < self.params.seg_min_num:
                num_seg = self.params.seg_min_num

            # store number of sub-segments in this master-segment
            self.master_num_seg.append(num_seg)

            # define centerline sampling based on FIRST group element (consistent with with legacy behavior)
            sample0, points0, areas0 = self.sample_group(self.original.group_elems[i][0])

            # uniform sampling along centerline
            sample_1d = np.linspace(0, 1, num_seg + 1)

            # adaptive mesh refinement based on area change if desired
            if self.params.seg_size_adaptive:
                # calculate mesh density
                area_x = sample0 * self.original.group_length[i]
                area_change = np.abs(np.gradient(np.log(areas0 / np.mean(areas0)), area_x))
                density = 1 + area_change

                # iteratively place nodes according to segment density
                for e in range(100):
                    sample_1d_old = sample_1d

                    # interpolate segment size on new [0, 1] domain
                    seg_size = interp1d(sample_1d[1:], sample0, 1 / density / (num_seg + 1))

                    # create new [0, 1] domain
                    sample_1d = np.insert(np.cumsum(seg_size), 0, 0)
                    sample_1d /= sample_1d[-1]

                    if np.linalg.norm(sample_1d - sample_1d_old) < 1e-12:
                        break

            # loop all (mostly overlapping) centerline elements of master-segment group
            areas_g = np.zeros(num_seg + 1)
            for j in range(len(self.original.group_elems[i])):
                # sample group points and areas
                _, _, areas = self.sample_group(self.original.group_elems[i][j], sample_1d)

                # interpolate areas along 1d centerline and add to cumulative sum
                areas_g += areas

            # get average over ALL centerline group elements (consistent with with legacy behavior)
            areas_g *= self.params.Acoef / len(self.original.group_elems[i])

            # get FIRST group element for nodes, not average (consistent with with legacy behavior)
            nodes_g = self.params.lcoef * interp1d(sample_1d[1:], sample0, points0)

            # get sub-segment lengths
            length_g = self.params.lcoef * np.diff(sample_1d) * self.original.group_length[i]

            # loop all sub-segments to collect information for output
            for j in range(num_seg):
                # append sub-nodes
                self.fine.nodes.append(tuple(nodes_g[j]))

                # split in segment in/out
                self.fine.group_Ain.append(areas_g[j])
                self.fine.group_Aout.append(areas_g[j + 1])

                # every sub-segment in master-segment belongs to the same centerline element
                self.fine.group_elems.append(self.original.group_elems[i])

                # divide master-segment length uniformly among sub-segments
                self.fine.group_length.append(length_g[j])

                # only last sub-segment of master-segment can be outlet
                if self.original.group_terminal[i] == 1 and j == num_seg - 1:
                    self.fine.group_terminal.append(1)
                else:
                    self.fine.group_terminal.append(0)

        self.master_num_seg = np.array(self.master_num_seg)

    def sample_group(self, group, sample=None):
        """
        Sample points and areas of a centerline group along a path
        Args:
            group: id of centerline group
            sample: optional, sample points in [0, 1] (default: sample at centerline points)

        Returns:
        path of centerline points in [0, 1],sampled points, sampled areas
        """
        # get area on each point on centerline
        area = np.pi * self.original.get_point_data(self.original.PointDataFields.MAX_INSCRIBED_RADIUS) ** 2

        # get element
        ele = self.original.centerlines_geometry.GetCell(group)

        # get point coordinates and global ids
        points = nps.vtk_to_numpy(ele.GetPoints().GetData())
        point_ids = np.array([ele.GetPointIds().GetId(i) for i in range(ele.GetPointIds().GetNumberOfIds())])

        # get cumulative distances between points (= path along centerline)
        distances = np.cumsum(np.insert(np.linalg.norm(np.diff(points, axis=0), axis=1), 0, 0))

        # remove possible duplicates
        distances, i_unique = np.unique(distances, return_index=True)
        points = points[i_unique]
        point_ids = point_ids[i_unique]

        # map 1d centerline path to interval [0,1]
        path_1d = distances / distances[-1]

        # if sampling is given, interpolate areas along 1d centerline and add to cumulative sum
        if sample is not None:
            areas = interp1d(sample, path_1d, area[point_ids])

        # return areas along original path
        else:
            areas = area[point_ids]

        return path_1d, points, areas

    def refine_connectivity(self):
        """
        Create refined sub-segment connectivity
        """
        # indices of master nodes (= original nodes) in refined geometry
        master_node_id = np.insert(np.cumsum(self.master_num_seg), 0, 0)

        # add start/end node for each sub-segment

        # loop master-segments
        self.fine.seg_rear = []
        self.fine.seg_head = []
        for i in range(self.original.num_seg):
            # end nodes of sub-segments in master-segment
            seg_rear_g = master_node_id[i] + 1 + np.arange(0, self.master_num_seg[i])

            # start nodes of sub-segments in master-segment
            seg_head_g = seg_rear_g - 1
            seg_head_g[0] = np.sum(self.master_num_seg[:self.original.seg_head[i]])

            # append to global list
            self.fine.seg_rear += seg_rear_g.tolist()
            self.fine.seg_head += seg_head_g.tolist()

        # add existing joints (bifurcations)
        # note: the above connectivity information would be sufficient to reconstruct the geometry.
        #       to comply with the Mesh class also explicitly compute joints in seg_connectivity

        # loop existing joints
        self.fine.seg_connectivity = []
        for ele in self.original.seg_connectivity:
            # inlet segment: last sub-segment of master-segment
            joint = [master_node_id[ele[0] + 1] - 1]

            # outlet segments: first sub-segments of master-segments
            joint += (master_node_id[np.array(ele[1:])]).tolist()

            self.fine.seg_connectivity.append(joint)

        # add new joints for connected sub-segments of each master-segment

        # loop master-segments
        for i in range(self.original.num_seg):

            # loop sub-segments of master-segment
            for j in range(self.master_num_seg[i] - 1):
                # add connection between two adjacent sub-segments
                ele = master_node_id[i] + j + np.array([0, 1])
                self.fine.seg_connectivity += [ele.tolist()]

        # store properties of fine mesh
        self.fine.num_seg = master_node_id[-1]

        # todo: new fine mesh doesn't correspond to centerline groups anymore, this is a workaround
        # maybe introduce new naming scheme based on dictionaries?
        self.fine.num_groups = self.fine.num_seg
        self.fine.seg_list = np.arange(self.fine.num_seg).tolist()


def interp1d(x, xp, fp):
    """
    Mimic behavior of scipy.interpolate.interp1d (extend np.interp to multi-dimensional function values)
    Args:
        x: sample points
        xp: data points
        fp: data values (xD)

    Returns:
        y: interpolated values (xD)
    """
    if len(fp.shape) > 1:
        y = np.zeros((x.shape[0], fp.shape[1]))
        for d in range(fp.shape[1]):
            y[:, d] = np.interp(x, xp, fp[:, d])
    else:
        y = np.interp(x, xp, fp)
    return y
